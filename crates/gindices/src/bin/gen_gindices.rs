// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use beacon_state::mainnet::ElectraBeaconState as BeaconState;
use ethereum_consensus::electra::Validator;
use quote::format_ident;
use quote::quote;
use ssz_rs::GeneralizedIndexable;
use ssz_rs::List;
use ssz_rs::Path;
use ssz_rs::PathElement;

static PREAMBLE: &str = r#"// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by `gen_gindices.rs`.
"#;

pub const VALIDATOR_REGISTRY_LIMIT: usize = 2usize.pow(40);

fn main() {
    let state_fns = gen_guest_gindices_impl(&beacon_gindices::<BeaconState>());
    let block_fns = gen_guest_gindices_impl(&block_gindices::<
        ethereum_consensus::electra::BeaconBlockHeader,
    >());
    let validators_fns = validators_gindices();

    let tokens = quote! {
        #state_fns
        #block_fns
        #validators_fns

        /// Returns the gindex for the length of a List<> type
        #[inline(always)]
        pub const fn length_gindex() -> u64 {
            3u64
        }
    };

    let syntax_tree = syn::parse2(tokens).unwrap();
    let formatted = prettyplease::unparse(&syntax_tree);
    let formatted = format!("{PREAMBLE}\n{formatted}");

    print!("{}", formatted);
}

fn gen_guest_gindices_impl(
    gindices: &[(String, String, String, proc_macro2::TokenStream)],
) -> proc_macro2::TokenStream {
    let gindex_impls = gindices.iter().map(|(name, ret_type, root, value)| {
        let method_name = format_ident!("{}_gindex", name);
        let return_type = syn::parse_str::<syn::Type>(ret_type).unwrap();
        let comment = format!(" Returns the gindex of {name} from {root}");
        quote! {
            #[doc = #comment]
            #[inline(always)]
            pub const fn #method_name() -> #return_type {
                #value
            }
        }
    });

    quote! {
        #(#gindex_impls)*
    }
}

fn validators_gindices() -> proc_macro2::TokenStream {
    let base_gindex =
        <List<Validator, { VALIDATOR_REGISTRY_LIMIT }>>::generalized_index(Path::from(&[0.into()]))
            .unwrap() as u64;

    let validator_chunk_count = Validator::chunk_count() as u64;

    // static paths for the Validator
    let g = [
        (
            "effective_balance",
            Path::from(&["effective_balance".into()]),
        ),
        (
            "withdrawal_credentials",
            Path::from(&["withdrawal_credentials".into()]),
        ),
        ("slashed", Path::from(&["slashed".into()])),
        ("activation_epoch", Path::from(&["activation_epoch".into()])),
        ("exit_epoch", Path::from(&["exit_epoch".into()])),
    ]
    .map(|(name, path)| gen_gindices::<Validator>(name.to_string(), path))
    .map(|(name, ret_type, value)| (name.to_string(), ret_type, quote!(#value)))
    .to_vec();

    let v: proc_macro2::TokenStream = g
        .into_iter()
        .map(|(name, ret_type, value)| {
            let method_name = format_ident!("{}_gindex", name);
            let return_type = syn::parse_str::<syn::Type>(&ret_type).unwrap();
            let comment = format!(" Returns the gindex of {name} from Validator i");
            quote! {
                    #[doc = #comment]
                    #[inline(always)]
                    pub const fn #method_name(i: u64) -> #return_type {
                        const CHUNK_OFFSET: u64 = #value / #validator_chunk_count;
                        const WITHIN_CHUNK: u64 = #value % #validator_chunk_count;
                        (#base_gindex + (i as u64)) * #validator_chunk_count * CHUNK_OFFSET + WITHIN_CHUNK
                    }
                }
        })
        .collect();

    quote! {
        #v
    }
}

fn block_gindices<G>() -> Vec<(String, String, String, proc_macro2::TokenStream)>
where
    G: GeneralizedIndexable,
{
    // Static paths for the BeaconBlock
    [
        ("state_root", Path::from(&["state_root".into()])),
        ("block_slot", Path::from(&["slot".into()])),
    ]
    .map(|(name, path)| gen_gindices::<G>(name.to_string(), path))
    .map(|(name, ret_type, value)| (name.to_string(), ret_type, "BeaconBlock".to_string(), value))
    .to_vec()
}

// Returns name, return type, the root of the path, and value
fn beacon_gindices<G>() -> Vec<(String, String, String, proc_macro2::TokenStream)>
where
    G: GeneralizedIndexable,
{
    // Static paths for the BeaconState
    [
        // (
        //     "validator_count",
        //     Path::from(&["validators".into(), PathElement::Length]),
        // ),
        ("validators", Path::from(&["validators".into()])),
        (
            "state_roots_base",
            Path::from(&["state_roots".into(), 0.into()]),
        ),
        (
            "historical_summaries_base",
            Path::from(&["historical_summaries".into(), 0.into()]),
        ),
        (
            "validator_balance_base",
            Path::from(&["balances".into(), 0.into()]),
        ),
        (
            "validator_withdrawal_credentials_base",
            Path::from(&[
                "validators".into(),
                0.into(),
                "withdrawal_credentials".into(),
            ]),
        ),
        (
            "validator_exit_epoch_base",
            Path::from(&["validators".into(), 0.into(), "exit_epoch".into()]),
        ),
    ]
    .map(|(name, path)| gen_gindices::<G>(name.to_string(), path))
    .map(|(name, ret_type, value)| (name.to_string(), ret_type, "BeaconState".to_string(), value))
    .to_vec()
}

fn gen_gindices<G>(name: String, path: &[PathElement]) -> (String, String, proc_macro2::TokenStream)
where
    G: GeneralizedIndexable,
{
    (name, "u64".to_string(), {
        let gindex = G::generalized_index(path).unwrap() as u64;
        quote!(#gindex)
    })
}
